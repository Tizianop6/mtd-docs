{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"TOF/modules/TrackExtenderWithMTD/","title":"TrackExtenderWithMTD","text":"<p>Abstract</p> <p>This producer module (<code>EDProducer</code>) adds time and related information to the event, including:</p> <ul> <li>time of arrival at MTD () with uncertainty;</li> <li>time of flight (henceforth TOF) under 3 different mass hypotheses (, , ) with uncertainty;</li> <li>length of travelled path from primary vertex to MTD;</li> <li>information on track matching to BTL, ETL hits (spatial and time match );</li> <li>momentum,  and  of each track at innermost point.</li> </ul>"},{"location":"TOF/modules/TrackExtenderWithMTD/#class-definition","title":"Class definition","text":"<p>Since <code>TrackExtenderWithMTD</code> class is designed to work with possibly different types of track collections, a template class <code>TrackExtenderwithMTDT</code> is defined as: <pre><code>template &lt;class TrackCollection&gt;\nclass TrackExtenderWithMTDT : public edm::stream::EDProducer&lt;&gt;;\n</code></pre></p> <p>Although the collection can be changed, it is now meant to work with <code>reco::TrackCollection</code>:</p> <pre><code>typedef TrackExtenderWithMTDT&lt;reco::TrackCollection&gt; TrackExtenderWithMTD;\n</code></pre>"},{"location":"TOF/modules/TrackExtenderWithMTD/#code-flow","title":"Code flow","text":"<p>The main entrypoint is the <code>produce()</code> method. Although each called method is described in full detail the Methods section below, an overall summary is here provided. For each track, <code>produce()</code>:</p> <ol> <li>first matches BTL and ETL hits to the track using the <code>tryBTLLayers()</code>, <code>tryETLLayers()</code> methods. If matched, trajectory and track hit list is updated to also include MTD hits. The association with hits is what determines  for the track. It should be noted that, in order for an approximate evaluation of time compatibility between the track and MTD hits, the <code>trackPathLength()</code> method is first invoked here, although its output is not used at this point for the actual TOF calculation.</li> <li>By using the <code>buildTrack()</code> method, the updated track is built, also calculating the path length between vertex and MTD, the associated TOF under different mass hypotheses and kinematic quantities obtained in the calculation. It is at this step that track back-propagation to vertex is performed, evaluating the track momentum at each tracker hit: all this information is contained in a <code>TrackSegments</code> object, built by the <code>trackPathLength()</code> method. This object is then fed to the <code>computeTrackTofPidInfo()</code> method for TOF claculation, which saves all info to a <code>TrackTofPidInfo</code> object. Each rebuilt track is stored in a track collection that will be saved to the event in the final step.</li> <li>By using the <code>buildTrackExtra()</code> method, track extra information, most notably including its hit collection, is populated and associated to the track re-built in the previous step.</li> <li>The rebuilt tracks, their associated track extras and associated reco hits are saved back into the <code>Event</code> (respectively as <code>TrackCollection</code>, <code>TrackExtraCollection</code>, <code>TrackingRecHit</code>). All previously evaluted time information is instead stored as a <code>ValueMap</code> and saved in the event through the <code>fillValueMap()</code> method. </li> </ol> <p>The overall call flow is hence as follows: <pre><code>produce()\n\u251c\u2500\u2500 tryBTLLayers()\n\u251c\u2500\u2500 tryETLLayers()\n\u251c\u2500\u2500 trackPathLength()#(1)!\n\u251c\u2500\u2500 buildTrack()\n\u2502   \u251c\u2500\u2500 trackPathLength()\n\u2502   \u2514\u2500\u2500 computeTrackTofPidInfo()\n\u251c\u2500\u2500 buildTrackExtra()\n\u2514\u2500\u2500 fillValueMap()\n</code></pre></p> <ol> <li>called, but not used for actual TOF evaluation (second call is)</li> </ol>"},{"location":"TOF/modules/TrackExtenderWithMTD/#methods","title":"Methods","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#trybtllayers","title":"<code>tryBTLLayers()</code>","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#tryetllayers","title":"<code>tryETLLayers()</code>","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#buildtrack","title":"<code>buildTrack()</code>","text":"Prototype<pre><code>template &lt;class TrackCollection&gt;\nreco::Track TrackExtenderWithMTDT&lt;TrackCollection&gt;::buildTrack( //(1)!\n    const reco::TrackRef&amp; orig,\n    const Trajectory&amp; traj,\n    const Trajectory&amp; trajWithMtd,\n    const reco::BeamSpot&amp; bs,\n    const MagneticField* field,\n    const Propagator* thePropagator,\n    bool hasMTD,\n    float&amp; pathLengthOut,\n    float&amp; tmtdOut,\n    float&amp; sigmatmtdOut,\n    float&amp; tofpi,\n    float&amp; tofk,\n    float&amp; tofp,\n    float&amp; sigmatofpi,\n    float&amp; sigmatofk,\n    float&amp; sigmatofp\n    ) const;\n</code></pre> <ol> <li>buildTrack is a template method (to which the <code>template &lt;class TrackCollection&gt;</code> heading refers to) of a template class (hence <code>TrackExtenderWithMTDT&lt;TrackCollection&gt;</code>) returning a <code>reco::Track</code> value</li> </ol>"},{"location":"TOF/modules/TrackExtenderWithMTD/#steps","title":"Steps","text":"<ol> <li>Calculate path length by invoking <code>trackPathLength()</code></li> <li>Calculate  depending on whether track crossed:<ul> <li>BLT: since only 1 hit can be recorded, track time is equal to that hit time;</li> <li>ELT: since 2 hits must be always recorded, defining the innermost hit as hit #1 and the outermost as hit #2:<ul> <li>propagate track from hit #2 back to hit #1, evaluating  with  (i.e. uncertainty is inflated by TOF variation given by extreme mass hypotheses of pion and proton)</li> <li>if  and  are compatible (i.e. they pass a given  cut), their weighted average is taken as MTD time. Spatial hit corresponds to hit #1.</li> </ul> </li> </ul> </li> <li>Calculate TOF by invoking <code>computeTrackTofPidInfo()</code> using the <code>TofCalc::kSegm</code> option (i.e. taking into account the variation in momentum along propagation).</li> </ol>"},{"location":"TOF/modules/TrackExtenderWithMTD/#output","title":"Output","text":"<p>Returns <code>reco::Track</code> with same trajectory as input one (i.e. including matched MTD hit) with the evaluated time at vertex.  Also saves the following value in the argument references:</p> <ul> <li>MTD time and relative uncertainty as defined above;</li> <li>travelled path length (as per <code>trackPathLength()</code>);</li> <li>time of flight under , ,  mass hypotheses with relative uncertainty (as per <code>computeTrackTofPidInfo()</code>).</li> </ul>"},{"location":"TOF/modules/TrackExtenderWithMTD/#buildtrackextra","title":"buildTrackExtra()","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#computetracktofpidinfo","title":"computeTrackTofPidInfo()","text":"Prototype<pre><code>const TrackTofPidInfo computeTrackTofPidInfo(\n    float magp2,\n    float length,\n    TrackSegments trs,\n    float t_mtd,\n    float t_mtderr,\n    float t_vtx,\n    float t_vtx_err,\n    bool addPIDError = true,\n    TofCalc choice = TofCalc::kCost,\n    SigmaTofCalc sigma_choice = SigmaTofCalc::kCost);\n</code></pre>"},{"location":"TOF/modules/TrackExtenderWithMTD/#steps_1","title":"Steps","text":"<p>Supports three TOF calculation strategies:</p> <ul> <li><code>TofCalc::kConst</code>: assuming constant momentum, evaluated TOF as ;</li> <li><code>TofCalc::kSegm</code>: takes into account the variation of momentum due to energy loss through propagation. Uses the <code>TrackSegments::computeTof()</code>, <code>TrackSegments::computeSigmaTof()</code> methods;</li> <li><code>TofCalc::kMixd</code>: calculates . No physical meaning, only defined for convenience of use inside <code>tryBTLLayers()</code>, <code>tryETLLayers()</code>.</li> </ul> <p>The calculation is repeated for the pion, kaon and proton mass hypotheses. The associated  and  is also evaluated.</p> <p>The time difference with respect to the primary vertex is calculated as  corresponding to the time of the particle at the vertex. The associated uncertainty is, crucially, defined as: </p> <p> </p> <p>where  (i.e. difference between TOF in pion and proton hypothesis). This last term is only included if <code>addPIDError = 1</code>.</p> Why is uncertainty evaluated this way? <p>By inflating the uncertainty on the time at vertex in this way, we are taking into account the uncertainty on the actual particle ID. This is used in the first iteration of the 4D vertex reconstruction algorithm, where different mass hypotheses cannot be resolved until a first version of vertex candidates is provided.</p> <p>Lastly, a likelihood for each mass hypothesis  is evaluated as:</p> <p> </p> <p>If any hypothesis performs better in terms of  with respect to the pion hypothesis,  is overriden by that hypothesis.</p>"},{"location":"TOF/modules/TrackExtenderWithMTD/#output_1","title":"Output","text":"<p>Fills a <code>TrackTofPidInfo</code> struct with all the required information (see structure for list of member variables).</p>"},{"location":"TOF/modules/TrackExtenderWithMTD/#trackpathlength","title":"trackPathLength()","text":"Prototype<pre><code>bool trackPathLength(const Trajectory&amp; traj,\n                     const TrajectoryStateClosestToBeamLine&amp; tscbl,\n                     const Propagator* thePropagator,\n                     float&amp; pathlength,\n                     TrackSegments&amp; trs);\n</code></pre>"},{"location":"TOF/modules/TrackExtenderWithMTD/#steps_2","title":"Steps","text":"<p>Note</p> <p>Since it only calculates propagation lengths, it does not make use of any mass hypothesis. It only needs to know momentum.</p> <p>Iterating over trajectory measurements (starting from outermost, first in order),</p> <ol> <li>propagates track state to the surface of the next measurement (i.e. to the previous hit);</li> <li>saves the calculated segment using <code>TrackSegments::addSegment()</code>, saving the propagated , the squared momentum magnitude at the beginning of each trajectory segment and its associated uncertainty, as obtained from <code>TrajectoryState::curvilinearError()</code> (internally calculated after track fitting through the Kalman filter algorithm);</li> </ol> <p>In the end, the track segment associated to the propagation from the innermost trajectory measurement (i.e. first tracker hit) to the extrapolated beam spot is also computed.</p> Used Propagator <p>Uses the <code>PropagatorWithMaterialForMTD</code> propagator, i.e. a <code>PropagatorWithMaterial</code> propagator taking into account material effects, with the following parameters: <pre><code>Mass = cms.double(0.13957018),\nMaxDPhi = cms.double(1.6),\nPropagationDirection = cms.string('anyDirection'),\nptMin = cms.double(0.1),\nuseOldAnalPropLogic = cms.bool(False),\nuseRungeKutta = cms.bool(False)\n</code></pre> Notice the usage of an analytical propagator.</p>"},{"location":"TOF/modules/TrackExtenderWithMTD/#output_2","title":"Output","text":"<p>Saves sum of partial propagation lengths  to input argument <code>pathlength</code>.</p> <p>Populates output <code>TrackSegments</code> with list of segments, each containing info on partial propagation length , squared momentum magnitude  at the beginning of each segment and uncertainty on momentum.</p> <p>Returns <code>bool validpropagation</code> checking if <code>pathlength &gt; 0</code> for each single propagated segment. If even a single segment fails, propagation is not considered valid.</p>"},{"location":"TOF/modules/TrackExtenderWithMTD/#fillvaluemap","title":"fillValueMap()","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#classes","title":"Classes","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#tracksegments","title":"TrackSegments","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#member-variables","title":"Member variables","text":"<pre><code>uint32_t nSegment_ = 0;\nstd::vector&lt;float&gt; segmentPathOvc_;  // segment lengths\nstd::vector&lt;float&gt; segmentMom2_;     // squared momentum at the start of each segment\nstd::vector&lt;float&gt; segmentSigmaMom_; // uncertainty on momentum (not squared)\n</code></pre>"},{"location":"TOF/modules/TrackExtenderWithMTD/#methods_1","title":"Methods","text":"<ul> <li><code>float computeSigmaTof(float mass_inv2)</code>: computes  as sum of partial pathlength over each segment , with  depending on the mass hypothesis <code>mass_inv2</code>;</li> <li><code>float computeSigmaTof(float mass_inv2) const</code>: computes  assuming a complete correlation between all momentum measurements, resulting in the formula   </li> </ul> <p>using the  as obtained in <code>trackPathLength()</code>.</p>  calculation <p>As , taking into account the pair-wise correlation between segments descending from the momentum measurement correlation:  where . We here assume all segments to be fully correlated () (due to the fact the Kalman filter algorithm does not return them; however, we can assume them to be strongly correlated, since the momentum variation through propagation --as well as its associated uncertainty-- is small). Partial derivatives amount to 1.</p> <p>Since , we have:</p> <p> </p> <p>hence the formula above.</p> <p>Notice both methods refer to the <code>kSegm</code> calculation strategy, and are invoked within <code>computeTrackTofPidInfo()</code>.</p>"},{"location":"TOF/modules/TrackExtenderWithMTD/#tracktofpidinfo","title":"TrackTofPidInfo","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#member-variables_1","title":"Member variables","text":"<pre><code>float tmtd;         // time of associated MTD hit\nfloat tmtderror;    // uncertainty\nfloat pathlength;   // travelled distance between MTD hit and beamline PCA\n\nfloat betaerror;    // difference in beta between pion and proton mass hp\n\nfloat dt;           // time difference between vertex and track beamline PCA\nfloat dterror;\nfloat dtchi2;\n\nfloat dt_best;      // dt under mass hypothesis with smallest dtchi2\nfloat dterror_best;\nfloat dtchi2_best;\n\nfloat gammasq_pi;\nfloat beta_pi;\nfloat dt_pi;\nfloat sigma_dt_pi;\n\nfloat gammasq_k;\nfloat beta_k;\nfloat dt_k;\nfloat sigma_dt_k;\n\nfloat gammasq_p;\nfloat beta_p;\nfloat dt_p;\nfloat sigma_dt_p;\n\nfloat prob_pi;\nfloat prob_k;\nfloat prob_p;\n</code></pre> <p>See <code>computeTrackTofPidInfo</code> for how each variable is computed.</p>"},{"location":"TOF/modules/TrackExtenderWithMTD/#output_3","title":"Output","text":"<p>The main output quantities are here summarized again, with pointers to the method which calculates them:</p>"},{"location":"home/generatingsamples/","title":"Generating samples","text":"<p>In case the RelVal samples are not enough to carry out an in-depth study, this page shows how to generate samples from scratch.</p>"},{"location":"home/generatingsamples/#generating-samples-at-pu0-and-with-vanilla-cmssw","title":"Generating samples at PU=0 and with vanilla CMSSW","text":"<p>A good place to start is to take RelVals as an example and then produce them privately.</p> <p>For instance, one can search for existing SingleMu samples, e.g. <code>/RelValSingleMuPt10/*CMSSW_15_1_0_pre1*mcRun4*/GEN-SIM-RECO</code> on DAS. </p> <p>One of the results is the following: <code>/RelValSingleMuPt10/CMSSW_15_1_0_pre1-141X_mcRun4_realistic_v3_STD_RegeneratedGS_Run4D110_noPU-v1/GEN-SIM-RECO</code>, namely a Single Muon sample at pT = 10 GeV generated at PU = 0 and using CMSSW_15_1_0_pre1.</p> <p>After finding the dataset name, you can look it up on the RelVal website: searching for <code>/RelValSingleMuPt10/CMSSW_15_1_0_pre1-141X_mcRun4_realistic_v3_STD_RegeneratedGS_Run4D110_noPU-v1/GEN-SIM-RECO</code> one gets to the following page and can access the cmsDriver commands by clicking on the appropriate link under the \"Actions\" section.</p> <p>The cmsDriver commands are the ones used to build the config files for the RelVals, and are a good starting point to start private generation.</p> <p>Now, moving to an lxplus machine, you can start the generation by creating your working directory and downloading a local version of CMSSW. Highly suggested to use the same version of the RelVal reference sample, in our case CMSSW_15_1_0_pre1. </p> <p>You can have a local version using the following command:</p> <pre><code>cmsrel CMSSW_15_1_0_pre1\n</code></pre> <p>then you can enter the source directory and set the environment variables</p> <pre><code>cd CMSSW_15_1_0_pre1\ncd src\ncmsenv\n</code></pre> <p>now, in a directory of your choice, you can run the cmsDriver commands in order to produce the config files that are able to carry out the sample generation. </p> <pre><code>cd ..\nmkdir yoursampledir\ncd yoursampledir\n</code></pre> <p>And then you can run the first cmsDriver command:</p> <pre><code>cmsDriver.py SingleMuPt10_Eta2p85_cfi --beamspot DBrealisticHLLHC --conditions auto:phase2_realistic_T33_13TeV --customise SLHCUpgradeSimulations/Configuration/aging.customise_aging_1000 --datatier GEN-SIM --era Phase2C17I13M9 --eventcontent FEVTDEBUG --fileout \"file:step1.root\" --geometry ExtendedRun4D110 --nStreams 1 --nThreads 8 --no_exec --number 10 --python_filename step_1_cfg.py --relval 9000,100 --step GEN,SIM || exit $?\n</code></pre> <p>here we will not discuss all the parameters given to cmsDriver, the reference is here.</p> <p>The produced file contains the following part:</p> <pre><code>process.generator = cms.EDFilter(\"Pythia8PtGun\",\n    PGunParameters = cms.PSet(\n    AddAntiParticle = cms.bool(True),\n    MaxEta = cms.double(2.85),\n    MaxPhi = cms.double(3.14159265359),\n    MaxPt = cms.double(10.01),\n    MinEta = cms.double(-2.85),\n    MinPhi = cms.double(-3.14159265359),\n    MinPt = cms.double(9.99),\n    ParticleID = cms.vint32(-13)\n    ),\n    PythiaParameters = cms.PSet(\n    parameterSets = cms.vstring()\n    ),\n    Verbosity = cms.untracked.int32(0),\n    firstRun = cms.untracked.uint32(1),\n    psethack = cms.string('single mu pt 10')\n)\n</code></pre> <p>above you can set the kind of particle that you are producing, the kinematic range, and the presence of an additional antiparticle shot back-to-back with respect to the first one.</p> <p>Take a look also at this part, which is a the beginning of the config file, in order to set the number of events that are generated:</p> <pre><code>process.maxEvents = cms.untracked.PSet(\n    input = cms.untracked.int32(10),\n    output = cms.optional.untracked.allowed(cms.int32,cms.PSet)\n)\n</code></pre> <p>Afterwards, you can carry out the generation by sending the command:</p> <pre><code>cmsRun step_1_cfg.py\n</code></pre> <p>The same can be done for the next steps, you can carry out the generation of the config files in the following  way:</p> <pre><code># Command for step 2:\ncmsDriver.py step2 --conditions auto:phase2_realistic_T33 --customise SLHCUpgradeSimulations/Configuration/aging.customise_aging_1000 --datatier GEN-SIM-DIGI-RAW --era Phase2C17I13M9 --eventcontent FEVTDEBUGHLT --filein \"file:step1.root\" --fileout \"file:step2.root\" --geometry ExtendedRun4D110 --nStreams 1 --nThreads 8 --no_exec --number 10 --python_filename step_2_cfg.py --step DIGI:pdigi_valid,L1TrackTrigger,L1,L1P2GT,DIGI2RAW,HLT:@relvalRun4 || exit $?\n\n# Command for step 3:\ncmsDriver.py step3 --conditions auto:phase2_realistic_T33 --customise SLHCUpgradeSimulations/Configuration/aging.customise_aging_1000 --datatier GEN-SIM-RECO,MINIAODSIM,DQMIO --era Phase2C17I13M9 --eventcontent FEVTDEBUGHLT,MINIAODSIM,DQM --filein \"file:step2.root\" --fileout \"file:step3.root\" --geometry ExtendedRun4D110 --nStreams 1 --nThreads 8 --no_exec --number 10 --python_filename step_3_cfg.py --step RAW2DIGI,RECO,RECOSIM,PAT,VALIDATION:@phase2Validation+@miniAODValidation,DQM:@phase2+@miniAODDQM || exit $?\n\n# Command for step 4:\ncmsDriver.py step4 --conditions auto:phase2_realistic_T33 --customise SLHCUpgradeSimulations/Configuration/aging.customise_aging_1000 --era Phase2C17I13M9 --filein \"file:step3_inDQM.root\" --fileout \"file:step4.root\" --filetype DQM --geometry ExtendedRun4D110 --mc --nStreams 1 --no_exec --number 10 --python_filename step_4_cfg.py --scenario pp --step HARVESTING:@phase2Validation+@phase2+@miniAODValidation+@miniAODDQM || exit $?\n\n# Command for step 5:\ncmsDriver.py step5 --conditions auto:phase2_realistic_T33 --customise SLHCUpgradeSimulations/Configuration/aging.customise_aging_1000 --datatier ALCARECO --era Phase2C17I13M9 --eventcontent ALCARECO --filein \"file:step3.root\" --fileout \"file:step5.root\" --geometry ExtendedRun4D110 --nStreams 1 --nThreads 8 --no_exec --number 10 --python_filename step_5_cfg.py --step ALCA:SiPixelCalSingleMuonLoose+SiPixelCalSingleMuonTight+TkAlMuonIsolated+TkAlMinBias+MuAlOverlaps+EcalESAlign+TkAlZMuMu+TkAlDiMuonAndVertex+HcalCalHBHEMuonProducerFilter+TkAlUpsilonMuMu+TkAlJpsiMuMu || exit $?\n</code></pre> <p>and then you can run the n-th step in this way:</p> <pre><code>cmsRun step_n_cfg.py\n</code></pre>"},{"location":"home/generatingsamples/#generating-samples-with-an-edited-version-of-cmssw","title":"Generating samples with an edited version of CMSSW","text":"<p>In order to generate samples with a non-production version of CMSSW, after downloading locally a CMSSW version with cmsrel, you can download some edits from an already existing branch of CMSSW committed on a personal fork of the repository. For instance you can download the edited files with the <code>git cms-checkout-topic</code> command, e.g. :</p> <pre><code> git cms-checkout-topic Tizianop6:ntuplizer_tracks_forPathLength\n</code></pre> <p>Another option to do this, in the case you want to manually modify the code of a package, is to follow the advice given in the CMSSW documentation. Namely, you can download locally a package with the <code>git cms-addpkg</code> command, e.g.:</p> <pre><code> git cms-addpkg DataFormats/TestObjects\n</code></pre> <p>then you can edit the code.</p> <p>After the code is downloaded from an existing branch, or after you developments, you can compile:</p> <pre><code> scram b -j4\n</code></pre> <p>And you can go ahead with the <code>cmsDriver</code> and then <code>cmsRun</code> commands</p>"},{"location":"home/generatingsamples/#mixing-adding-pu","title":"Mixing: adding PU","text":""}]}