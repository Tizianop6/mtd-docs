{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"TOF/modules/TrackExtenderWithMTD/","title":"TrackExtenderWithMTD","text":"<p>Abstract</p> <p>This producer module (<code>EDProducer</code>) adds time and related information to the event, including:</p> <ul> <li>time of arrival at MTD () with uncertainty;</li> <li>time of flight (henceforth TOF) under 3 different mass hypotheses (, , ) with uncertainty;</li> <li>length of travelled path from primary vertex to MTD;</li> <li>information on track matching to BTL, ETL hits (spatial and time match );</li> <li>momentum,  and  of each track at innermost point.</li> </ul>"},{"location":"TOF/modules/TrackExtenderWithMTD/#class-definition","title":"Class definition","text":"<p>Since <code>TrackExtenderWithMTD</code> class is designed to work with possibly different types of track collections, a template class <code>TrackExtenderwithMTDT</code> is defined as: <pre><code>template &lt;class TrackCollection&gt;\nclass TrackExtenderWithMTDT : public edm::stream::EDProducer&lt;&gt;;\n</code></pre></p> <p>Although the collection can be changed, it is now meant to work with <code>reco::TrackCollection</code>:</p> <pre><code>typedef TrackExtenderWithMTDT&lt;reco::TrackCollection&gt; TrackExtenderWithMTD;\n</code></pre>"},{"location":"TOF/modules/TrackExtenderWithMTD/#code-flow","title":"Code flow","text":"<p>The main entrypoint is the <code>produce()</code> method. Although each called method is described in full detail the Methods section below, an overall summary is here provided. For each track, <code>produce()</code>:</p> <ol> <li>first matches BTL and ETL hits to the track using the <code>tryBTLLayers()</code>, <code>tryETLLayers()</code> methods. If matched, trajectory and track hit list is updated to also include MTD hits. The association with hits is what determines  for the track. It should be noted that, in order for an approximate evaluation of time compatibility between the track and MTD hits, the <code>trackPathLength()</code> method is first invoked here, although its output is not used at this point for the actual TOF calculation.</li> <li>By using the <code>buildTrack()</code> method, the updated track is built, also calculating the path length between vertex and MTD, the associated TOF under different mass hypotheses and kinematic quantities obtained in the calculation. It is at this step that track back-propagation to vertex is performed, evaluating the track momentum at each tracker hit: all this information is contained in a <code>TrackSegments</code> object, built by the <code>trackPathLength()</code> method. This object is then fed to the <code>computeTrackTofPidInfo()</code> method for TOF claculation, which saves all info to a <code>TrackTofPidInfo</code> object. Each rebuilt track is stored in a track collection that will be saved to the event in the final step.</li> <li>By using the <code>buildTrackExtra()</code> method, track extra information, most notably including its hit collection, is populated and associated to the track re-built in the previous step.</li> <li>The rebuilt tracks, their associated track extras and associated reco hits are saved back into the <code>Event</code> (respectively as <code>TrackCollection</code>, <code>TrackExtraCollection</code>, <code>TrackingRecHit</code>). All previously evaluted time information is instead stored as a <code>ValueMap</code> and saved in the event through the <code>fillValueMap()</code> method. </li> </ol> <p>The overall call flow is hence as follows: <pre><code>produce()\n\u251c\u2500\u2500 tryBTLLayers()\n\u251c\u2500\u2500 tryETLLayers()\n\u251c\u2500\u2500 trackPathLength()#(1)!\n\u251c\u2500\u2500 buildTrack()\n\u2502   \u251c\u2500\u2500 trackPathLength()\n\u2502   \u2514\u2500\u2500 computeTrackTofPidInfo()\n\u251c\u2500\u2500 buildTrackExtra()\n\u2514\u2500\u2500 fillValueMap()\n</code></pre></p> <ol> <li>called, but not used for actual TOF evaluation (second call is)</li> </ol>"},{"location":"TOF/modules/TrackExtenderWithMTD/#methods","title":"Methods","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#trybtllayers","title":"<code>tryBTLLayers()</code>","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#tryetllayers","title":"<code>tryETLLayers()</code>","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#buildtrack","title":"<code>buildTrack()</code>","text":"Prototype<pre><code>template &lt;class TrackCollection&gt;\nreco::Track TrackExtenderWithMTDT&lt;TrackCollection&gt;::buildTrack( //(1)!\n    const reco::TrackRef&amp; orig,\n    const Trajectory&amp; traj,\n    const Trajectory&amp; trajWithMtd,\n    const reco::BeamSpot&amp; bs,\n    const MagneticField* field,\n    const Propagator* thePropagator,\n    bool hasMTD,\n    float&amp; pathLengthOut,\n    float&amp; tmtdOut,\n    float&amp; sigmatmtdOut,\n    float&amp; tofpi,\n    float&amp; tofk,\n    float&amp; tofp,\n    float&amp; sigmatofpi,\n    float&amp; sigmatofk,\n    float&amp; sigmatofp\n    ) const;\n</code></pre> <ol> <li>buildTrack is a template method (to which the <code>template &lt;class TrackCollection&gt;</code> heading refers to) of a template class (hence <code>TrackExtenderWithMTDT&lt;TrackCollection&gt;</code>) returning a <code>reco::Track</code> value</li> </ol>"},{"location":"TOF/modules/TrackExtenderWithMTD/#steps","title":"Steps","text":"<ol> <li>Calculate path length by invoking <code>trackPathLength()</code></li> <li>Calculate  depending on whether track crossed:<ul> <li>BLT: since only 1 hit can be recorded, track time is equal to that hit time;</li> <li>ELT: since 2 hits must be always recorded, defining the innermost hit as hit #1 and the outermost as hit #2:<ul> <li>propagate track from hit #2 back to hit #1, evaluating  with  (i.e. uncertainty is inflated by TOF variation given by extreme mass hypotheses of pion and proton)</li> <li>if  and  are compatible (i.e. they pass a given  cut), their weighted average is taken as MTD time. Spatial hit corresponds to hit #1.</li> </ul> </li> </ul> </li> <li>Calculate TOF by invoking <code>computeTrackTofPidInfo()</code> using the <code>TofCalc::kSegm</code> option (i.e. taking into account the variation in momentum along propagation).</li> </ol>"},{"location":"TOF/modules/TrackExtenderWithMTD/#output","title":"Output","text":"<p>Returns <code>reco::Track</code> with same trajectory as input one (i.e. including matched MTD hit) with the evaluated time at vertex.  Also saves the following value in the argument references:</p> <ul> <li>MTD time and relative uncertainty as defined above;</li> <li>travelled path length (as per <code>trackPathLength()</code>);</li> <li>time of flight under , ,  mass hypotheses with relative uncertainty (as per <code>computeTrackTofPidInfo()</code>).</li> </ul>"},{"location":"TOF/modules/TrackExtenderWithMTD/#buildtrackextra","title":"buildTrackExtra()","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#computetracktofpidinfo","title":"computeTrackTofPidInfo()","text":"Prototype<pre><code>const TrackTofPidInfo computeTrackTofPidInfo(\n    float magp2,\n    float length,\n    TrackSegments trs,\n    float t_mtd,\n    float t_mtderr,\n    float t_vtx,\n    float t_vtx_err,\n    bool addPIDError = true,\n    TofCalc choice = TofCalc::kCost,\n    SigmaTofCalc sigma_choice = SigmaTofCalc::kCost);\n</code></pre>"},{"location":"TOF/modules/TrackExtenderWithMTD/#steps_1","title":"Steps","text":"<p>Supports three TOF calculation strategies:</p> <ul> <li><code>TofCalc::kConst</code>: assuming constant momentum, evaluated TOF as ;</li> <li><code>TofCalc::kSegm</code>: takes into account the variation of momentum due to energy loss through propagation. Uses the <code>TrackSegments::computeTof()</code>, <code>TrackSegments::computeSigmaTof()</code> methods;</li> <li><code>TofCalc::kMixd</code>: calculates . No physical meaning, only defined for convenience of use inside <code>tryBTLLayers()</code>, <code>tryETLLayers()</code>.</li> </ul> <p>The calculation is repeated for the pion, kaon and proton mass hypotheses. The associated  and  is also evaluated.</p> <p>The time difference with respect to the primary vertex is calculated as  corresponding to the time of the particle at the vertex. The associated uncertainty is, crucially, defined as: </p> <p> </p> <p>where  (i.e. difference between TOF in pion and proton hypothesis). This last term is only included if <code>addPIDError = 1</code>.</p> Why is uncertainty evaluated this way? <p>By inflating the uncertainty on the time at vertex in this way, we are taking into account the uncertainty on the actual particle ID. This is used in the first iteration of the 4D vertex reconstruction algorithm, where different mass hypotheses cannot be resolved until a first version of vertex candidates is provided.</p> <p>Lastly, a likelihood for each mass hypothesis  is evaluated as:</p> <p> </p> <p>If any hypothesis performs better in terms of  with respect to the pion hypothesis,  is overriden by that hypothesis.</p>"},{"location":"TOF/modules/TrackExtenderWithMTD/#output_1","title":"Output","text":"<p>Fills a <code>TrackTofPidInfo</code> struct with all the required information (see structure for list of member variables).</p>"},{"location":"TOF/modules/TrackExtenderWithMTD/#trackpathlength","title":"trackPathLength()","text":"Prototype<pre><code>bool trackPathLength(const Trajectory&amp; traj,\n                     const TrajectoryStateClosestToBeamLine&amp; tscbl,\n                     const Propagator* thePropagator,\n                     float&amp; pathlength,\n                     TrackSegments&amp; trs);\n</code></pre>"},{"location":"TOF/modules/TrackExtenderWithMTD/#steps_2","title":"Steps","text":"<p>Note</p> <p>Since it only calculates propagation lengths, it does not make use of any mass hypothesis. It only needs to know momentum.</p> <p>Iterating over trajectory measurements (starting from outermost, first in order),</p> <ol> <li>propagates track state to the surface of the next measurement (i.e. to the previous hit);</li> <li>saves the calculated segment using <code>TrackSegments::addSegment()</code>, saving the propagated , the squared momentum magnitude at the beginning of each trajectory segment and its associated uncertainty, as obtained from <code>TrajectoryState::curvilinearError()</code> (internally calculated after track fitting through the Kalman filter algorithm);</li> </ol> <p>In the end, the track segment associated to the propagation from the innermost trajectory measurement (i.e. first tracker hit) to the extrapolated beam spot is also computed.</p> Used Propagator <p>Uses the <code>PropagatorWithMaterialForMTD</code> propagator, i.e. a <code>PropagatorWithMaterial</code> propagator taking into account material effects, with the following parameters: <pre><code>Mass = cms.double(0.13957018),\nMaxDPhi = cms.double(1.6),\nPropagationDirection = cms.string('anyDirection'),\nptMin = cms.double(0.1),\nuseOldAnalPropLogic = cms.bool(False),\nuseRungeKutta = cms.bool(False)\n</code></pre> Notice the usage of an analytical propagator.</p>"},{"location":"TOF/modules/TrackExtenderWithMTD/#output_2","title":"Output","text":"<p>Saves sum of partial propagation lengths  to input argument <code>pathlength</code>.</p> <p>Populates output <code>TrackSegments</code> with list of segments, each containing info on partial propagation length , squared momentum magnitude  at the beginning of each segment and uncertainty on momentum.</p> <p>Returns <code>bool validpropagation</code> checking if <code>pathlength &gt; 0</code> for each single propagated segment. If even a single segment fails, propagation is not considered valid.</p>"},{"location":"TOF/modules/TrackExtenderWithMTD/#fillvaluemap","title":"fillValueMap()","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#classes","title":"Classes","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#tracksegments","title":"TrackSegments","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#member-variables","title":"Member variables","text":"<pre><code>uint32_t nSegment_ = 0;\nstd::vector&lt;float&gt; segmentPathOvc_;  // segment lengths\nstd::vector&lt;float&gt; segmentMom2_;     // squared momentum at the start of each segment\nstd::vector&lt;float&gt; segmentSigmaMom_; // uncertainty on momentum (not squared)\n</code></pre>"},{"location":"TOF/modules/TrackExtenderWithMTD/#methods_1","title":"Methods","text":"<ul> <li><code>float computeSigmaTof(float mass_inv2)</code>: computes  as sum of partial pathlength over each segment , with  depending on the mass hypothesis <code>mass_inv2</code>;</li> <li><code>float computeSigmaTof(float mass_inv2) const</code>: computes  assuming a complete correlation between all momentum measurements, resulting in the formula   </li> </ul> <p>using the  as obtained in <code>trackPathLength()</code>.</p>  calculation <p>As , taking into account the pair-wise correlation between segments descending from the momentum measurement correlation:  where . We here assume all segments to be fully correlated () (due to the fact the Kalman filter algorithm does not return them; however, we can assume them to be strongly correlated, since the momentum variation through propagation --as well as its associated uncertainty-- is small). Partial derivatives amount to 1.</p> <p>Since , we have:</p> <p> </p> <p>hence the formula above.</p> <p>Notice both methods refer to the <code>kSegm</code> calculation strategy, and are invoked within <code>computeTrackTofPidInfo()</code>.</p>"},{"location":"TOF/modules/TrackExtenderWithMTD/#tracktofpidinfo","title":"TrackTofPidInfo","text":""},{"location":"TOF/modules/TrackExtenderWithMTD/#member-variables_1","title":"Member variables","text":"<pre><code>float tmtd;         // time of associated MTD hit\nfloat tmtderror;    // uncertainty\nfloat pathlength;   // travelled distance between MTD hit and beamline PCA\n\nfloat betaerror;    // difference in beta between pion and proton mass hp\n\nfloat dt;           // time difference between vertex and track beamline PCA\nfloat dterror;\nfloat dtchi2;\n\nfloat dt_best;      // dt under mass hypothesis with smallest dtchi2\nfloat dterror_best;\nfloat dtchi2_best;\n\nfloat gammasq_pi;\nfloat beta_pi;\nfloat dt_pi;\nfloat sigma_dt_pi;\n\nfloat gammasq_k;\nfloat beta_k;\nfloat dt_k;\nfloat sigma_dt_k;\n\nfloat gammasq_p;\nfloat beta_p;\nfloat dt_p;\nfloat sigma_dt_p;\n\nfloat prob_pi;\nfloat prob_k;\nfloat prob_p;\n</code></pre> <p>See <code>computeTrackTofPidInfo</code> for how each variable is computed.</p>"},{"location":"TOF/modules/TrackExtenderWithMTD/#output_3","title":"Output","text":"<p>The main output quantities are here summarized again, with pointers to the method which calculates them:</p>"}]}